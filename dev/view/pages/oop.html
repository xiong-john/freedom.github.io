<html><head></head><body><h1 id="js-">js面向对象学习</h1>
<h2 id="-">为什么要面向对象</h2>
<p>`
But first, why do we care about inheritance at all? There are primarily two reasons. The first is type convenience. We want the language system to automatically cast references of similar classes. Little type-safety is obtained from a type system which requires the routine explicit casting of object references. This is of critical importance in strongly-typed languages, but it is irrelevant in loosely-typed languages like JavaScript, where object references never need casting.</p>
<p>The second reason is code reuse. It is very common to have a quantity of objects all implementing exactly the same methods. Classes make it possible to create them all from a single set of definitions. It is also common to have objects that are similar to some other objects, but differing only in the addition or modification of a small number of methods. Classical inheritance is useful for this but prototypal inheritance is even more useful.
`
两个方面：便利（convenience）和重用(reuse)。</p>
<h2 id="-">面向对象基础知识</h2>
<ul>
<li><p>特点：抽象类，实例对象</p>
<ul>
<li><p>封装
隐藏某一方法的具体运行步骤，取而代之的是通过消息传递机制发送消息给它。通过限制只有特定类的对象可以访问这一特定类的成员，而它们通常利用接口实现消息的传入传出。（公有成员，私有，保护）。防止对象受到外界干扰，防止其他对象依赖可能变化的细节，信息隐藏有助于对象和模块直接的松散耦合。最佳实践：对象之间只通过方法访问。</p>
</li>
<li><p>继承
在某种情况下，子类比原本的类要更加具体化。 当一个类从多个父类继承时，成为“多重继承”。继承含有是一个或者是一种的关系。</p>
</li>
<li><p>多态
由继承产生的相关的不同的类，其对象对同一消息会做出不同反应。（运算符重载）</p>
</li>
<li><p>抽象性
简化复杂现实问题的途径。为具体问题找到最恰当的类定义，并可以在最恰当的继承级别解释问题。</p>
</li>
<li><p>类
有<code>公共属性</code>和<code>行为</code>的一组对象可以抽象成类，对象通常根据你所感兴趣的属性而分类。</p>
</li>
<li><p>对象
有唯一标示，可以分成许多种类（即类），可以继承或聚合。行为、职责明确，接口与实现分离，隐藏内部结构，有不同的状态。可以提供服务，可以给其他对象发送消息，从其他对象接受消息， 并作出相应响应，可以把职责委托给其他对象。</p>
</li>
</ul>
</li>
</ul>
<h2 id="js-">JS实现各种面向对象特性的方式</h2>
<h3 id="-">一、封装</h3>
<p>  JS根据作用域链，可以使用闭包将私有成员隐藏。构造函数是本身。</p>
<pre><code><div class="highlight"><pre>  <span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="nx">c</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">c</span> <span class="o">=</span> <span class="nx">c</span> <span class="o">||</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">getB</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="k">return</span> <span class="nx">b</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setB</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">val</span><span class="p">){</span>
      <span class="nx">b</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">();</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">c</span><span class="p">;</span> <span class="c1">//4;</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">b</span><span class="p">;</span> <span class="c1">//undefined;</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">getB</span><span class="p">();</span> <span class="c1">//2</span>
</pre></div>

</code></pre><h3 id="-">二、继承</h3>
<ul>
<li><p>最简单的实现方法</p>
<p>派生类继承基类的属性和行为。利用prototype（原型链， 所有实例共享一个原型对象，修改原型对象则继承对象都改变）可以实现继承，也可以自己用遍历拷贝的方式来实现。</p>
</li>
</ul>
<pre><code><div class="highlight"><pre>  <span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">B</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">d</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">();</span>

  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">();</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">a</span><span class="p">;</span> <span class="c1">//1;</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">c</span><span class="p">;</span> <span class="c1">//3;</span>
</pre></div>

</code></pre><p>这样继承是可枚举的变量：</p>
<pre><code><div class="highlight"><pre>  <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">//a, b, c, d;</span>
</pre></div>

</code></pre><ul>
<li><p>被继承的属性需要非常注意，因为如果属性是引用类型的话，在子类实例修改被继承的该属性后，会导致所有子类实例都改变：</p>
<pre><code><div class="highlight"><pre><span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>
<span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">B</span><span class="p">(){</span>
<span class="k">this</span><span class="p">.</span><span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">this</span><span class="p">.</span><span class="nx">d</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">this</span><span class="p">.</span><span class="nx">f</span> <span class="o">=</span> <span class="p">{};</span> <span class="c1">//引用类型</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">();</span>
<span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">();</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">a1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">();</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nx">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nx">a</span><span class="p">.</span><span class="nx">f</span><span class="p">;</span><span class="c1">// {c:1}</span>
<span class="nx">a1</span><span class="p">.</span><span class="nx">f</span><span class="p">;</span> <span class="c1">//{c:1}</span>
</pre></div>

</code></pre></li>
</ul>
<p>注意： 按原型链，下一层的原型对象会覆盖上一层的原型对象的属性和方法。</p>
<ul>
<li>高级一点的实现方法
简单的实现方法的缺点： <ul>
<li>一、没有传统的super方法(this指当前对象， super指父类)
解决的方式，使用JS的<code>apply</code>/<code>call</code>方法，将父类的构造函数绑定在当前类使用；</li>
</ul>
</li>
</ul>
<ul>
<li><p>二、在prototype继承的时候new 出来的原型对象会产生多余的constructor， 并将其赋予被继承的类； 
（所以 a.constructor == B; //true, a.constructor == A; //false）</p>
<ul>
<li>Object.prototype.constructor 
所有对象都会从它的原型上继承一个 constructor 属性：</li>
</ul>
<pre><code><div class="highlight"><pre><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">Person</span><span class="p">))</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
<span class="p">}</span>
</pre></div>

</code></pre><p>--- 防止被直接当函数使用而创建全局变量</p>
</li>
</ul>
<h3 id="-">三、多态</h3>
<p><a href="http://tobyho.com/2010/11/22/javascript-constructors-and/">http://tobyho.com/2010/11/22/javascript-constructors-and/</a></p>
<p><a href="http://purplebamboo.github.io/2014/07/13/javascript-oo-class/">http://purplebamboo.github.io/2014/07/13/javascript-oo-class/</a></p>
<p><a href="http://javascript.crockford.com/inheritance.html">http://javascript.crockford.com/inheritance.html</a></p>
</body></html>